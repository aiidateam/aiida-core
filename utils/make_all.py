import ast
from collections import Counter
from pathlib import Path
from pprint import pprint
import sys
from typing import List, Optional, Tuple


def parse_all(folder_path: str) -> Tuple[dict, dict]:
    """Walk through all files in folder, and parse the ``__all__`` variable.
    
    :return: (all dict, dict of unparsable)
    """
    folder_path = Path(folder_path)
    all_dict = {}
    bad_all = {}

    for path in folder_path.glob("**/*.py"):

        # skip module files
        if path.name == "__init__.py":
            continue

        # parse the file
        parsed = ast.parse(path.read_text(encoding="utf8"))

        # find __all__ assignment
        all_token = None
        for token in parsed.body:
            if not isinstance(token, ast.Assign):
                continue
            if token.targets and getattr(token.targets[0], "id", "") == "__all__":
                all_token = token
                break

        if all_token is None:
            bad_all.setdefault("missing", []).append(str(path.relative_to(folder_path)))
            continue

        if not isinstance(all_token.value, (ast.List, ast.Tuple)):
            bad_all.setdefault("vaue not list/tuple", []).append(str(path.relative_to(folder_path)))
            continue

        if not all(isinstance(el, ast.Str) for el in all_token.value.elts):
            bad_all.setdefault("child not strings", []).append(str(path.relative_to(folder_path)))
            continue

        names = [n.s for n in all_token.value.elts]
        if not names:
            continue

        path_dict = all_dict
        for part in path.parent.relative_to(folder_path).parts:
            path_dict = path_dict.setdefault(part, {})
        path_dict.setdefault(path.name[:-3], {})["__all__"] = names

    return all_dict, bad_all


def gather_all(all_dict: dict, all_list: Optional[List[str]] = None) -> List[str]:
    """Recursively gather __all__ names."""
    all_list = [] if all_list is None else all_list
    for key, val in all_dict.items():
        if key == "__all__":
            all_list.extend(val)
        else:
            gather_all(val, all_list)
    return all_list


def write_inits(folder_path: str, all_dict: dict, skip_children: dict) -> dict:
    """Write __init__.py files for all subfolders.
    
    :return: folders with non-unique imports
    """
    folder_path = Path(folder_path)
    non_unique = {}
    for path in folder_path.glob("**/__init__.py"):
        if path.parent == folder_path:
            # skip top level __init__.py
            continue
        rel_path = path.parent.relative_to(folder_path).as_posix()
        # get sub_dict for this folder
        path_all_dict = all_dict
        try:
            for part in path.parent.relative_to(folder_path).parts:
                path_all_dict = path_all_dict[part]
        except KeyError:
            continue
        path_all_dict = {key: val for key, val in path_all_dict.items() if key not in skip_children.get(rel_path, [])}
        alls = gather_all(path_all_dict)
        if not alls:
            continue
        # check for non-unique imports
        if len(alls) != len(set(alls)):
            non_unique[rel_path] = [k for k, v in Counter(alls).items() if v > 1]
        content = (["", "# AUTO-GENERATED"] + ["# yapf: disable", "# pylint: disable=wildcard-import", ""] +
                   [f"from .{mod} import *" for mod in sorted(path_all_dict.keys())] + ["", "__all__ = ("] +
                   [f"    {a!r}," for a in sorted(set(alls))] + [")", ""])

        new_content = []
        in_docstring = False
        for line in path.read_text(encoding="utf8").splitlines():
            # only use initial comments and docstring
            if not (line.startswith("#") or line.startswith('"""') or in_docstring):
                break
            if line.startswith('"""'):
                if (not in_docstring) and not (line.endswith('"""') and not line.strip() == '"""'):
                    in_docstring = True
                else:
                    in_docstring = False
            if not line.startswith("# pylint"):
                new_content.append(line)

        # could warn if overwriting any non-autogenerated content

        new_content.extend(content)

        path.write_text("\n".join(new_content), encoding="utf8")

    return non_unique


if __name__ == "__main__":
    _folder = Path(__file__).parent.parent.joinpath("aiida")
    _skip = {
        "orm": "implementation",
        "orm/implementation": ["django", "sqlalchemy", "sql"],
        "cmdline": ["params"],
        "cmdline/params": ["arguments", "options"]
    }
    _all_dict, _bad_all = parse_all(_folder)
    _non_unique = write_inits(_folder, _all_dict, _skip)
    _bad_all.pop("missing", "")  # allow missing __all__
    if _bad_all:
        print("unparsable __all__:")
        pprint(_bad_all)
    if _non_unique:
        print("non-unique imports:")
        pprint(_non_unique)
    if _bad_all or _non_unique:
        sys.exit(1)
