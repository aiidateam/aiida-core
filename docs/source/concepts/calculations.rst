.. _concepts_calculations:

************
Calculations
************

A calculation is a process (see the :ref:`process section<concepts_processes>` for details) that *creates* new data.
Currently, there are two ways of implementing a calculation process:

 * :ref:`calculation function<concepts_calcfunctions>`
 * :ref:`calculation job<concepts_calcjobs>`

The first one is the simplest of the two and is basically a python function that is magically transformed into a process.
This is ideal for calculations that are not very computationally intensive and can be easily implemented in a python function.
For more taxing calculations, typically performed by external codes that are optionally run on remote computing clusters, the calculation job is the better alternative.

In the following sections, both concepts will be explained but without going too much into detail on how to implement or run them.
For a more detailed expos√©, please refer to the respective advanced sections on :ref:`calculation functions<working_calcfunctions>` and :ref:`calculation jobs<working_calcjobs>`.


.. _concepts_calcfunctions:

Calculation functions
=====================

Consider the following computational task at hand:

.. highlights::
    Given three integers, add the first two and then multiply the sum by the third.

In plain python code, the solution would look something like the following:

.. include:: include/snippets/calculations/calcfunctions/add_multiply_plain_python.py
    :code: python

This simple code snippet will achieve the goal of getting the desired result, however, the provenance is lost.
There is no connection between the output of the functions and their inputs.
The remedy to this problem is the :py:meth:`~aiida.engine.processes.functions.calcfunction`.
The ``calcfunction`` in AiiDA is a `function decorator <https://docs.python.org/3/glossary.html#term-decorator>`_ that transforms a regular python function in a calculation process, which automatically stores the provenance of its output in the :ref:`provenance graph<concepts_provenance>` when executed.
Updating the previous snippet with ``calcfunction`` decorators yields:

.. include:: include/snippets/calculations/calcfunctions/add_multiply_calcfunction_decorator.py
    :code: python

The only thing we had to do to decorate the two functions was to add the line ``@calcfunction`` just before the function definition.
Adding the decorator tells AiiDA that the provenance for this function should be stored in the provenance graph when it is executed.
This means linking up the inputs and the outputs for a calculation node, which represents the function that was executed.
The final change that has to be performed to make this possible, is to make the inputs and the outputs storable.
In the previous snippet, the inputs are plain python integer types, which cannot be automatically stored in the provenance graph as nodes.
To solve this, one only has to wrap them in the :py:class:`~aiida.orm.nodes.data.int.Int` node sub class, which makes them storable in the database:

.. include:: include/snippets/calculations/calcfunctions/add_multiply_calcfunction_data_types.py
    :code: python

The only difference with the previous snippet is that all inputs have been wrapped in the :py:class:`~aiida.orm.nodes.data.int.Int` class.
The result that is returned by the function, likewise, is a :py:class:`~aiida.orm.nodes.data.int.Int` node that contains the result of the computation.

.. note::
	Since ``x`` and ``y`` inside the function are already :py:class:`~aiida.orm.nodes.data.int.Int` instances the sum will also be one, since all arithmetic operators are overloaded.
	It is important to realize though that only :py:class:`~aiida.orm.nodes.node.Node` instances, or sub classes thereof can be stored.
	For more information on how to return results from process function, refer to the :ref:`advanced section<working_calcfunctions>`

With these trivial changes, the full provenance of result produced by running the function is maintained and looks like the following:

.. _fig_calculation_functions_provenance_add_multiply:
.. figure:: include/images/add_multiply_calcfunction_data.png

    The provenance generated by the calcfunction example

The examples above already showed how a calcfunction can be run: simply by calling it.
The value that is returned is the result returned by the definition of the function.
However, sometimes one would also like to have a reference to the calculation node that represents the execution of the function in the provenance graph.
The following snippet shows two additional launch functions that will return a tuple, that in addition to the results, also return the ``pk`` or the node associated with the process

.. include:: include/snippets/calculations/calcfunctions/add_multiply_calcfunction_run.py
    :code: python

This was a very short and limited description of calculation functions.
For a more detailed description of launching them, please refer to the section on :ref:`launching processes<working_processes_launching>`.
If you want more details on implementing calculation functions and best practices, refer to the section on :ref:`calculation function development<working_calcfunctions>`.


.. _concepts_calcjobs:

Calculation jobs
================

In the previous section on :ref:`calculation functions<concepts_calcfunctions>`, we showed how a simple python function can be transformed into a process, such that when it is launched, its execution is recorded automatically in the provenance graph.
However, not all computations are well suited to be implemented as a python function, but rather are implemented as a separate code, external to AiiDA.
To interface an external code with the engine of AiiDA, the :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class was introduced.
To illustrate how one can implement the ``CalcJob`` and launch it, we need an example external code.
Let's imagine an external code that consists of a script that reads an input file containing two integers, sums them and writes the sum to an output file.
The :py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation` is a calc job implementation that forms an interface for such a code.
In the following sections, we will use this implementation to explain the inner workings of the ``CalcJob`` class.

.. _concepts_calcjobs_transport_tasks:

`Issue [#2622] <https://github.com/aiidateam/aiida_core/issues/2622>`_
